<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-31T08:30:08.713207"><title>TP 5 : Un seul pour les gouverner tous - Mise en place de la Configuration Centralis&eacute;e | Spring Micro Services</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs Pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction-le-grand-d-m-nagement-de-la-configuration","level":0,"title":"Introduction : Le grand déménagement de la configuration","anchor":"#introduction-le-grand-d-m-nagement-de-la-configuration"},{"id":"tape-1-cr-ation-du-d-p-t-git-de-configuration","level":0,"title":"Étape 1 : Création du dépôt Git de configuration","anchor":"#tape-1-cr-ation-du-d-p-t-git-de-configuration"},{"id":"tape-2-cr-ation-du-spring-cloud-config-server","level":0,"title":"Étape 2 : Création du Spring Cloud Config Server","anchor":"#tape-2-cr-ation-du-spring-cloud-config-server"},{"id":"tape-3-migration-de-product-service-et-order-service","level":0,"title":"Étape 3 : Migration de product-service et order-service","anchor":"#tape-3-migration-de-product-service-et-order-service"},{"id":"tape-4-dockerisation-du-config-server","level":0,"title":"Étape 4 : Dockerisation du Config Server","anchor":"#tape-4-dockerisation-du-config-server"},{"id":"exercice-8-mettre-jour-la-configuration-chaud","level":0,"title":"Exercice 8 : Mettre à jour la configuration à chaud","anchor":"#exercice-8-mettre-jour-la-configuration-chaud"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="TP 5 : Un seul pour les gouverner tous - Mise en place de la Configuration Centralis&eacute;e | Spring Micro Services"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Spring Micro Services Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/005-01-tp-5.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="TP 5 : Un seul pour les gouverner tous - Mise en place de la Configuration Centralis&eacute;e | Spring Micro Services"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/005-01-tp-5.html#webpage",
    "url": "writerside-documentation/005-01-tp-5.html",
    "name": "TP 5 : Un seul pour les gouverner tous - Mise en place de la Configuration Centralis&eacute;e | Spring Micro Services",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Spring Micro Services Help"
}</script><!-- End Schema.org --></head><body data-id="005-01-TP-5" data-main-title="TP 5 : Un seul pour les gouverner tous - Mise en place de la Configuration Centralisée" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="005-00-centralized-configuration.md|Module 5 : La Configuration Centralisée (L'essentiel)"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Spring Micro Services  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="005-01-TP-5" id="005-01-TP-5.md">TP 5 : Un seul pour les gouverner tous - Mise en place de la Configuration Centralisée</h1><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs P&eacute;dagogiques</h2><p id="-yitlcw_12">&Agrave; la fin de ce TP, vous serez capable de :</p><ul class="list _bullet" id="-yitlcw_13"><li class="list__item" id="-yitlcw_14"><p id="-yitlcw_20">Cr&eacute;er et structurer un d&eacute;p&ocirc;t Git pour h&eacute;berger la configuration.</p></li><li class="list__item" id="-yitlcw_15"><p id="-yitlcw_21">Cr&eacute;er et configurer un projet Spring Cloud Config Server.</p></li><li class="list__item" id="-yitlcw_16"><p id="-yitlcw_22">Lier le Config Server au d&eacute;p&ocirc;t Git.</p></li><li class="list__item" id="-yitlcw_17"><p id="-yitlcw_23">Modifier les microservices existants pour qu'ils deviennent des clients du Config Server.</p></li><li class="list__item" id="-yitlcw_18"><p id="-yitlcw_24">Valider que la configuration est bien servie depuis une source externe.</p></li><li class="list__item" id="-yitlcw_19"><p id="-yitlcw_25">Dockeriser le Config Server.</p></li></ul></section><section class="chapter"><h2 id="introduction-le-grand-d-m-nagement-de-la-configuration" data-toc="introduction-le-grand-d-m-nagement-de-la-configuration">Introduction : Le grand d&eacute;m&eacute;nagement de la configuration</h2><p id="-yitlcw_26">Nos services <code class="code" id="-yitlcw_30">product-service</code> et <code class="code" id="-yitlcw_31">order-service</code> ont chacun leur propre fichier <code class="code" id="-yitlcw_32">application.properties</code>, leur petit &quot; Post-it&quot; personnel. Nous avons vu que c'&eacute;tait ing&eacute;rable &agrave; grande &eacute;chelle. Aujourd'hui, nous allons faire le grand m&eacute;nage. Nous allons cr&eacute;er notre &quot;panneau d'affichage central&quot; (le d&eacute;p&ocirc;t Git), construire le service qui le g&egrave;re (le Config Server), puis apprendre &agrave; nos services &agrave; venir y lire leurs instructions au lieu de se fier &agrave; leurs notes locales.</p><p id="-yitlcw_27">Ce TP est structur&eacute; en trois grandes parties :</p><ol class="list _decimal" id="-yitlcw_28" type="1"><li class="list__item" id="-yitlcw_33"><p id="-yitlcw_36"><span class="control" id="-yitlcw_37">Cr&eacute;ation de la source de v&eacute;rit&eacute; :</span> Le d&eacute;p&ocirc;t Git.</p></li><li class="list__item" id="-yitlcw_34"><p id="-yitlcw_38"><span class="control" id="-yitlcw_39">Cr&eacute;ation du fournisseur :</span> Le Config Server.</p></li><li class="list__item" id="-yitlcw_35"><p id="-yitlcw_40"><span class="control" id="-yitlcw_41">Mise &agrave; jour des consommateurs :</span> Nos microservices.</p></li></ol><p id="-yitlcw_29">&Agrave; la fin, l'URL d'Eureka ne sera plus &eacute;crite dans les fichiers <code class="code" id="-yitlcw_42">properties</code> de nos services, mais sera r&eacute;cup&eacute;r&eacute;e dynamiquement depuis un emplacement central. C'est un pas de g&eacute;ant vers une architecture propre et maintenable.</p></section><section class="chapter"><h2 id="tape-1-cr-ation-du-d-p-t-git-de-configuration" data-toc="tape-1-cr-ation-du-d-p-t-git-de-configuration">&Eacute;tape 1 : Cr&eacute;ation du d&eacute;p&ocirc;t Git de configuration</h2><section class="procedure-steps" id="-yitlcw_43"><p id="-yitlcw_44"><b id="-yitlcw_64">Option A : Utiliser un d&eacute;p&ocirc;t local (plus simple pour ce TP)</b></p><p id="-yitlcw_45">1. Sur votre machine, cr&eacute;ez un nouveau dossier, par exemple <code class="code" id="-yitlcw_65">gestbook-config-repo</code>.</p><p id="-yitlcw_46">2. Ouvrez un terminal &agrave; l'int&eacute;rieur de ce dossier et initialisez un d&eacute;p&ocirc;t Git :</p><p id="-yitlcw_48">3. Dans ce dossier, cr&eacute;ez les fichiers de configuration suivants :</p><p id="-yitlcw_49"><b id="-yitlcw_66"><code class="code" id="-yitlcw_67">application.properties</code></b></p><p id="-yitlcw_50">Ce fichier contiendra les propri&eacute;t&eacute;s communes &agrave; tous nos services.</p><div class="code-block" data-lang="properties">
# Propriété commune à tous les clients : l'adresse du serveur Eureka
eureka.client.serviceUrl.defaultZone=http://eureka-server:8761/eureka

# Permet de voir les beans chargés par la configuration distante

management.endpoints.web.exposure.include=health,info,configprops
</div><aside class="prompt" data-type="warning" data-title="" id="-yitlcw_52"><p><b id="-yitlcw_68">Nom d'h&ocirc;te `eureka-server`</b></p><p id="-yitlcw_69">Notez que nous utilisons le nom d'h&ocirc;te <code class="code" id="-yitlcw_70">eureka-server</code> et non plus <code class="code" id="-yitlcw_71">localhost</code>. C'est une anticipation pour quand nous utiliserons Docker Compose. Ce nom correspondra au nom du service dans le r&eacute;seau Docker.</p></aside><p id="-yitlcw_53"><b id="-yitlcw_72"><code class="code" id="-yitlcw_73">product-service.properties</code></b></p><p id="-yitlcw_54">Ce fichier contient les propri&eacute;t&eacute;s sp&eacute;cifiques au service produit.</p><div class="code-block" data-lang="properties">
# Port spécifique à product-service
server.port=8081

# Configuration H2 spécifique à product-service
spring.datasource.url=jdbc:h2:mem:productdb
spring.h2.console.path=/h2-console
</div><p id="-yitlcw_56"><b id="-yitlcw_74"><code class="code" id="-yitlcw_75">order-service.properties</code></b></p><p id="-yitlcw_57">Propri&eacute;t&eacute;s sp&eacute;cifiques au service commande.</p><div class="code-block" data-lang="properties">
# Port spécifique à order-service
server.port=8082

# Configuration H2 spécifique à order-service

spring.datasource.url=jdbc:h2:mem:orderdb
spring.h2.console.path=/h2-console

</div><p id="-yitlcw_59">4. &quot;Commitez&quot; ces fichiers dans votre d&eacute;p&ocirc;t Git local :</p><div class="code-block" data-lang="bash">
git add .
git commit -m &quot;Initial configuration for services&quot;
</div><p id="-yitlcw_61">Notre source de v&eacute;rit&eacute; est pr&ecirc;te ! Notez bien le chemin d'acc&egrave;s complet &agrave; ce dossier (par exemple, <code class="code" id="-yitlcw_76">/Users/votre-nom/projets/gestbook-config-repo</code>), nous en aurons besoin.</p><p id="-yitlcw_62"><b id="-yitlcw_77">Option B : Utiliser un d&eacute;p&ocirc;t distant (GitHub/GitLab)</b></p><p id="-yitlcw_63">La proc&eacute;dure est similaire : cr&eacute;ez un nouveau d&eacute;p&ocirc;t (priv&eacute; de pr&eacute;f&eacute;rence, pour ne pas exposer de secrets) sur votre plateforme favorite, clonez-le, ajoutez les fichiers, commitez et pushez.</p><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="tape-2-cr-ation-du-spring-cloud-config-server" data-toc="tape-2-cr-ation-du-spring-cloud-config-server">&Eacute;tape 2 : Cr&eacute;ation du Spring Cloud Config Server</h2><section class="procedure-steps" id="-yitlcw_78"><p id="-yitlcw_79"><b id="-yitlcw_95">2.1. Cr&eacute;ation du projet</b></p><p id="-yitlcw_80">Direction <a href="https://start.spring.io/" id="-yitlcw_96" data-external="true" rel="noopener noreferrer" target="_blank">start.spring.io</a>:</p><ul class="list _bullet" id="-yitlcw_81"><li class="list__item" id="-yitlcw_97"><p><b id="-yitlcw_100">Project :</b> Maven, <b id="-yitlcw_101">Language :</b> Java, <b id="-yitlcw_102">Spring Boot :</b> 3.2.x, <b id="-yitlcw_103">Java :</b> 17</p></li><li class="list__item" id="-yitlcw_98"><p><b id="-yitlcw_104">Metadata :</b></p><ul class="list _bullet" id="-yitlcw_105"><li class="list__item" id="-yitlcw_106"><p><b id="-yitlcw_109">Group :</b> <code class="code" id="-yitlcw_110">fr.formation.spring</code></p></li><li class="list__item" id="-yitlcw_107"><p><b id="-yitlcw_111">Artifact :</b> <code class="code" id="-yitlcw_112">config-server</code></p></li><li class="list__item" id="-yitlcw_108"><p><b id="-yitlcw_113">Package name :</b> <code class="code" id="-yitlcw_114">fr.formation.spring.configserver</code></p></li></ul></li><li class="list__item" id="-yitlcw_99"><p><b id="-yitlcw_115">Dependencies :</b></p><ul class="list _bullet" id="-yitlcw_116"><li class="list__item" id="-yitlcw_117"><p><code class="code" id="-yitlcw_119">Config Server</code> (dans la section Spring Cloud Configuration)</p></li><li class="list__item" id="-yitlcw_118"><p><code class="code" id="-yitlcw_120">Eureka Client</code> (le Config Server peut aussi &ecirc;tre un client Eureka !)</p></li></ul></li></ul><p id="-yitlcw_82">G&eacute;n&eacute;rez, t&eacute;l&eacute;chargez et ouvrez le projet.</p><p id="-yitlcw_83"><b id="-yitlcw_121">2.2. Activation et Configuration</b></p><p id="-yitlcw_84">Ouvrez la classe principale <code class="code" id="-yitlcw_122">ConfigServerApplication.java</code> et activez le r&ocirc;le de serveur :</p><div class="code-block" data-lang="java">
// package fr.formation.spring.configserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer // &lt;-- Active le rôle de Config Server
public class ConfigServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
</div><p id="-yitlcw_86">Maintenant, configurez-le dans <code class="code" id="-yitlcw_123">src/main/resources/application.properties</code>:</p><div class="code-block" data-lang="properties">
# Nom et port du service
spring.application.name=config-server
# 8888 est le port standard par convention pour un Config Server
server.port=8888

# Configuration pour pointer vers notre dépôt Git

spring.cloud.config.server.git.uri=file:///${user.home}/path/to/your/gestbook-config-repo

# Le Config Server s'enregistre lui-même auprès d'Eureka

# C'est une bonne pratique pour qu'il soit découvrable.

eureka.client.serviceUrl.defaultZone=http://eureka-server:8761/eureka
</div><aside class="prompt" data-type="warning" data-title="" id="-yitlcw_88"><p><b id="-yitlcw_124">Syntaxe de l'URI Git locale</b></p><p id="-yitlcw_125">Remplacez <code class="code" id="-yitlcw_127">/path/to/your/gestbook-config-repo</code> par le chemin absolu de votre d&eacute;p&ocirc;t.</p><ul class="list _bullet" id="-yitlcw_126"><li class="list__item" id="-yitlcw_128"><p>Sur macOS/Linux : <code class="code" id="-yitlcw_130">file:///Users/votre-nom/projets/gestbook-config-repo</code> (notez les <b id="-yitlcw_131">trois</b> slashes).</p></li><li class="list__item" id="-yitlcw_129"><p>Sur Windows : <code class="code" id="-yitlcw_132">file:///C:/Users/votre-nom/projets/gestbook-config-repo</code>.</p></li></ul></aside><p id="-yitlcw_89"><b id="-yitlcw_133">2.3. Lancement et Validation</b></p><p id="-yitlcw_90">Lancez le <code class="code" id="-yitlcw_134">ConfigServerApplication</code> depuis votre IDE. Une fois d&eacute;marr&eacute;, vous pouvez tester son API directement dans votre navigateur. L'API a une structure simple : <code class="code" id="-yitlcw_135">/{application-name}/{profile}</code>.</p><p id="-yitlcw_91">Testez l'URL suivante : <a href="http://localhost:8888/product-service/default" id="-yitlcw_136" data-external="true" rel="noopener noreferrer" target="_blank">http://localhost:8888/product-service/default</a></p><p id="-yitlcw_92">Vous devriez recevoir une r&eacute;ponse JSON qui contient les propri&eacute;t&eacute;s combin&eacute;es de <code class="code" id="-yitlcw_137">application.properties</code> et <code class="code" id="-yitlcw_138">product-service.properties</code> de votre d&eacute;p&ocirc;t Git !</p><div class="code-block" data-lang="json">
{
  &quot;name&quot;: &quot;product-service&quot;,
  &quot;profiles&quot;: [ &quot;default&quot; ],
  &quot;label&quot;: null,
  &quot;version&quot;: &quot;...&quot;,
  &quot;state&quot;: null,
  &quot;propertySources&quot;: [
    {
      &quot;name&quot;: &quot;file:///.../gestbook-config-repo/product-service.properties&quot;,
      &quot;source&quot;: {
        &quot;server.port&quot;: 8081,
        &quot;spring.datasource.url&quot;: &quot;jdbc:h2:mem:productdb&quot;,
        &quot;spring.h2.console.path&quot;: &quot;/h2-console&quot;
      }
    },
    {
      &quot;name&quot;: &quot;file:///.../gestbook-config-repo/application.properties&quot;,
      &quot;source&quot;: {
        &quot;eureka.client.serviceUrl.defaultZone&quot;: &quot;http://eureka-server:8761/eureka&quot;,
        ...
      }
    }
  ]
}
</div><p id="-yitlcw_94">Notre Config Server fonctionne !</p><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="tape-3-migration-de-product-service-et-order-service" data-toc="tape-3-migration-de-product-service-et-order-service">&Eacute;tape 3 : Migration de <code class="code" id="-yitlcw_142">product-service</code> et <code class="code" id="-yitlcw_143">order-service</code></h2><p id="-yitlcw_140">Il est temps d'apprendre &agrave; nos services &agrave; utiliser notre nouveau serveur. La proc&eacute;dure est la m&ecirc;me pour les deux. Nous allons la d&eacute;tailler pour <code class="code" id="-yitlcw_144">product-service</code>.</p><section class="procedure-steps" id="-yitlcw_141"><p id="-yitlcw_145">Ouvrez le projet <code class="code" id="-yitlcw_162">product-service</code>.</p><p id="-yitlcw_146"><b id="-yitlcw_163">3.1. Ajout des d&eacute;pendances</b></p><p id="-yitlcw_147">Dans le <code class="code" id="-yitlcw_164">pom.xml</code>, ajoutez les d&eacute;pendances pour le client de configuration et pour le bootstrap.</p><div class="code-block" data-lang="markup">
&lt;!-- Dans product-service/pom.xml --&gt;
&lt;dependencies&gt;
    &lt;!-- ... (dépendances existantes) ... --&gt;

    &lt;!-- Permet de parler au Config Server --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!-- Active la lecture du fichier bootstrap.properties --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</div><p id="-yitlcw_149">N'oubliez pas de recharger les d&eacute;pendances Maven.</p><p id="-yitlcw_150"><b id="-yitlcw_165">3.2. Cr&eacute;ation du `bootstrap.properties`</b></p><p id="-yitlcw_151">Dans <code class="code" id="-yitlcw_166">src/main/resources</code>, cr&eacute;ez un nouveau fichier nomm&eacute; <code class="code" id="-yitlcw_167">bootstrap.properties</code>.</p><div class="code-block" data-lang="properties">
# Ce fichier est lu avant application.properties
# Il contient le strict minimum pour contacter le Config Server

# Nom de notre application. C'est ce nom que le client enverra au

# Config Server pour demander sa configuration.

spring.application.name=product-service

# Adresse du Config Server

# Ici on peut utiliser localhost car c'est au moment du build/test local.

# En Docker, cette valeur sera surchargée.

spring.cloud.config.uri=http://localhost:8888

# On peut aussi configurer le client Eureka ici,

# car il est nécessaire au tout début du démarrage.

spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.service-id=config-server

</div><p id="-yitlcw_153"><b id="-yitlcw_168">3.3. Nettoyage de `application.properties`</b></p><p id="-yitlcw_154">Maintenant, nous pouvons supprimer toutes les propri&eacute;t&eacute;s qui sont g&eacute;r&eacute;es par le Config Server de notre fichier local <code class="code" id="-yitlcw_169">application.properties</code>.</p><p id="-yitlcw_155">Le fichier <code class="code" id="-yitlcw_170">application.properties</code> de <code class="code" id="-yitlcw_171">product-service</code> peut devenir presque vide, ou ne contenir que des propri&eacute;t&eacute;s sp&eacute;cifiques au d&eacute;veloppement local.</p><div class="code-block" data-lang="properties">
# Ce fichier est maintenant beaucoup plus léger !
# On peut y mettre des surcharges locales si besoin.
# Par exemple, pour les tests, on pourrait vouloir un niveau de log différent.
# logging.level.fr.formation.spring=DEBUG
</div><p id="-yitlcw_157"><b id="-yitlcw_172">3.4. R&eacute;p&eacute;tez pour `order-service`</b></p><p id="-yitlcw_158">Faites exactement la m&ecirc;me chose pour le projet <code class="code" id="-yitlcw_173">order-service</code>:</p><ol class="list _decimal" id="-yitlcw_159" type="1"><li class="list__item" id="-yitlcw_174"><p>Ajoutez les d&eacute;pendances <code class="code" id="-yitlcw_177">spring-cloud-starter-config</code> et <code class="code" id="-yitlcw_178">spring-cloud-starter-bootstrap</code>.</p></li><li class="list__item" id="-yitlcw_175"><p>Cr&eacute;ez un fichier <code class="code" id="-yitlcw_179">bootstrap.properties</code> avec <code class="code" id="-yitlcw_180">spring.application.name=order-service</code> et l'URL du Config Server.</p></li><li class="list__item" id="-yitlcw_176"><p>Nettoyez son <code class="code" id="-yitlcw_181">application.properties</code>.</p></li></ol><p id="-yitlcw_160"><b id="-yitlcw_182">3.5. Test final</b></p><ol class="list _decimal" id="-yitlcw_161" type="1"><li class="list__item" id="-yitlcw_183"><p>Assurez-vous que votre serveur Eureka est lanc&eacute;.</p></li><li class="list__item" id="-yitlcw_184"><p>Lancez votre Config Server depuis l'IDE.</p></li><li class="list__item" id="-yitlcw_185"><p>Lancez <code class="code" id="-yitlcw_188">product-service</code> depuis l'IDE. Observez les logs : vous devriez voir des lignes indiquant qu'il contacte le Config Server, comme <code class="code" id="-yitlcw_189">Fetching config from server at: http://localhost:8888</code>. V&eacute;rifiez dans Eureka qu'il s'est bien enregistr&eacute;.</p></li><li class="list__item" id="-yitlcw_186"><p>Lancez <code class="code" id="-yitlcw_190">order-service</code> depuis l'IDE. V&eacute;rifiez la m&ecirc;me chose.</p></li><li class="list__item" id="-yitlcw_187"><p>Testez l'appel de cr&eacute;ation de commande de `order-service` vers `product-service`. Tout doit fonctionner comme avant, mais cette fois, la configuration est venue de l'ext&eacute;rieur !</p></li></ol><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="tape-4-dockerisation-du-config-server" data-toc="tape-4-dockerisation-du-config-server">&Eacute;tape 4 : Dockerisation du Config Server</h2><p id="-yitlcw_191">Comme pour les autres, nous le mettons en conteneur.</p><ol class="list _decimal" id="-yitlcw_192" type="1"><li class="list__item" id="-yitlcw_195"><p id="-yitlcw_197">Cr&eacute;ez le <code class="code" id="-yitlcw_199">Dockerfile</code> &agrave; la racine de <code class="code" id="-yitlcw_200">config-server</code>.</p><div class="code-block" data-lang="dockerfile">
# ----- STAGE 1: Build -----
FROM maven:3.8.5-openjdk-17 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# ----- STAGE 2: Runtime -----
FROM eclipse-temurin:17-jre-focal
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8888
ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]
</div></li><li class="list__item" id="-yitlcw_196"><p id="-yitlcw_201">Construisez l'image :</p></li></ol><div class="code-block" data-lang="bash">
  mvn clean package
  docker build -t config-server:1.0 .
</div></section><section class="chapter"><h2 id="exercice-8-mettre-jour-la-configuration-chaud" data-toc="exercice-8-mettre-jour-la-configuration-chaud">Exercice 8 : Mettre &agrave; jour la configuration &agrave; chaud</h2><p id="-yitlcw_202"><span class="control" id="-yitlcw_206">Contexte :</span> Un des grands avantages du Config Server est de pouvoir changer la configuration sans red&eacute;marrer les services. Pour cela, les services doivent &ecirc;tre capables de rafra&icirc;chir leur configuration.</p><p id="-yitlcw_203"><span class="control" id="-yitlcw_207">Votre mission :</span></p><ol class="list _decimal" id="-yitlcw_204" type="1"><li class="list__item" id="-yitlcw_208"><p id="-yitlcw_217">Dans le <code class="code" id="-yitlcw_218">pom.xml</code> de <code class="code" id="-yitlcw_219">product-service</code>, ajoutez la d&eacute;pendance <code class="code" id="-yitlcw_220">spring-boot-starter-actuator</code>.</p></li><li class="list__item" id="-yitlcw_209"><p id="-yitlcw_221">Dans le fichier <code class="code" id="-yitlcw_222">application.properties</code> du d&eacute;p&ocirc;t Git (<code class="code" id="-yitlcw_223">gestbook-config-repo</code>), ajoutez la ligne suivante pour exposer l'endpoint de rafra&icirc;chissement : <code class="code" id="-yitlcw_224">management.endpoints.web.exposure.include=health,info,refresh</code>. Commitez ce changement.</p></li><li class="list__item" id="-yitlcw_210"><p id="-yitlcw_225">Arr&ecirc;tez et relancez <code class="code" id="-yitlcw_226">config-server</code> et <code class="code" id="-yitlcw_227">product-service</code> pour qu'ils prennent en compte ces changements.</p></li><li class="list__item" id="-yitlcw_211"><p id="-yitlcw_228">Dans le fichier <code class="code" id="-yitlcw_229">product-service.properties</code> du d&eacute;p&ocirc;t Git, ajoutez une nouvelle propri&eacute;t&eacute; : <code class="code" id="-yitlcw_230">welcome.message=Hello from Git!</code>. Commitez ce changement.</p></li><li class="list__item" id="-yitlcw_212"><p id="-yitlcw_231">Cr&eacute;ez un endpoint de test <code class="code" id="-yitlcw_232">GET /api/products/welcome</code> dans le <code class="code" id="-yitlcw_233">ProductController</code> qui lit cette propri&eacute;t&eacute; avec <code class="code" id="-yitlcw_234">@Value(&quot;${welcome.message}&quot;)</code> et la retourne. Relancez <code class="code" id="-yitlcw_235">product-service</code>. Appelez l'endpoint, il doit retourner &quot; Hello from Git!&quot;.</p></li><li class="list__item" id="-yitlcw_213"><p id="-yitlcw_236"><span class="control" id="-yitlcw_237">La partie int&eacute;ressante :</span> Modifiez la valeur de <code class="code" id="-yitlcw_238">welcome.message</code> dans le d&eacute;p&ocirc;t Git en &quot;Hello, configuration updated!&quot;. Commitez.</p></li><li class="list__item" id="-yitlcw_214"><p id="-yitlcw_239">Appelez &agrave; nouveau <code class="code" id="-yitlcw_240">GET /api/products/welcome</code>. Le message n'a pas chang&eacute;.</p></li><li class="list__item" id="-yitlcw_215"><p id="-yitlcw_241">Maintenant, faites un appel <code class="code" id="-yitlcw_242">POST</code> vide &agrave; l'endpoint Actuator de rafra&icirc;chissement : <code class="code" id="-yitlcw_243">http://localhost:8081/actuator/refresh</code>.</p></li><li class="list__item" id="-yitlcw_216"><p id="-yitlcw_244">Appelez une derni&egrave;re fois <code class="code" id="-yitlcw_245">GET /api/products/welcome</code>. Quel est le r&eacute;sultat et pourquoi ?</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="correction-exercice-8" data-toc="correction-exercice-8">Correction exercice 8</h3></div><div class="collapse__content"><ol class="list _decimal" id="-yitlcw_246" type="1"><li class="list__item" id="-yitlcw_251"><p id="-yitlcw_253">&agrave; 7. : En suivant les &eacute;tapes, vous constaterez qu'apr&egrave;s avoir modifi&eacute; la configuration dans Git, le service continue d'afficher l'ancien message &quot;Hello from Git!&quot;. C'est normal, il ne recharge pas sa configuration en permanence.</p></li><li class="list__item" id="-yitlcw_252"><p id="-yitlcw_254">L'appel <code class="code" id="-yitlcw_255">POST</code> &agrave; <code class="code" id="-yitlcw_256">/actuator/refresh</code> d&eacute;clenche un &eacute;v&eacute;nement de rafra&icirc;chissement dans le <code class="code" id="-yitlcw_257">product-service</code>. Le service va alors re-contacter le Config Server, demander sa configuration, et comparer la nouvelle version avec celle qu'il a en m&eacute;moire. Il ne mettra &agrave; jour que les beans annot&eacute;s avec <code class="code" id="-yitlcw_258">@ConfigurationProperties</code> ou <code class="code" id="-yitlcw_259">@RefreshScope</code>.</p></li></ol><p id="-yitlcw_247"><span class="control" id="-yitlcw_260">Pour que cela fonctionne sur notre <code class="code" id="-yitlcw_261">@Value</code>, il faut annoter la classe <code class="code" id="-yitlcw_262">ProductController</code> avec <code class="code" id="-yitlcw_263">@RefreshScope</code>.</span></p><div class="code-block" data-lang="java">
// Dans ProductController.java

import org.springframework.cloud.context.config.annotation.RefreshScope;
// ...

@RestController
@RequestMapping(&quot;/api/products&quot;)
@RefreshScope // &lt;-- Annotation cruciale !
public class ProductController {

    @Value(&quot;${welcome.message:Default Welcome}&quot;)
    private String welcomeMessage;
    // ... reste du contrôleur

    @GetMapping(&quot;/welcome&quot;)
    public String getWelcomeMessage() {
        return welcomeMessage;
    }
}
</div><ol class="list _decimal" id="-yitlcw_249" type="1" start="9"><li class="list__item" id="-yitlcw_264"><p id="-yitlcw_265"><span class="control" id="-yitlcw_266">R&eacute;sultat final :</span> Apr&egrave;s avoir ajout&eacute; <code class="code" id="-yitlcw_267">@RefreshScope</code>, relanc&eacute; le service, modifi&eacute; la config dans Git, et appel&eacute; <code class="code" id="-yitlcw_268">/actuator/refresh</code>, un nouvel appel &agrave; <code class="code" id="-yitlcw_269">/api/products/welcome</code> retournera <span class="control" id="-yitlcw_270">&quot;Hello, configuration updated!&quot;</span>. L'annotation <code class="code" id="-yitlcw_271">@RefreshScope</code> a permis au bean <code class="code" id="-yitlcw_272">ProductController</code> d'&ecirc;tre d&eacute;truit et recr&eacute;&eacute; avec la nouvelle valeur de la propri&eacute;t&eacute;, sans avoir &agrave; red&eacute;marrer toute l'application.</p></li></ol></div></div></section></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><ol class="list _decimal" id="-yitlcw_273" type="1"><li class="list__item" id="-yitlcw_275"><p id="-yitlcw_280"><span class="control" id="-yitlcw_282">(QCM)</span> Quel est le port par d&eacute;faut conventionnel pour un Spring Cloud Config Server ?</p><ul class="list _bullet" id="-yitlcw_281"><li class="list__item" id="-yitlcw_283"><p id="-yitlcw_287">A) 8080</p></li><li class="list__item" id="-yitlcw_284"><p id="-yitlcw_288">B) 8761</p></li><li class="list__item" id="-yitlcw_285"><p id="-yitlcw_289">C) 8888</p></li><li class="list__item" id="-yitlcw_286"><p id="-yitlcw_290">D) 9090</p></li></ul></li><li class="list__item" id="-yitlcw_276"><p id="-yitlcw_291"><span class="control" id="-yitlcw_292">(Question ouverte)</span> J'ai mis &agrave; jour un fichier de configuration dans mon d&eacute;p&ocirc;t Git. Que dois-je faire pour que mes microservices (d&eacute;j&agrave; d&eacute;marr&eacute;s) prennent en compte ce changement, et quelle d&eacute;pendance et annotation sont n&eacute;cessaires c&ocirc;t&eacute; client ?</p></li><li class="list__item" id="-yitlcw_277"><p id="-yitlcw_293"><span class="control" id="-yitlcw_295">(QCM)</span> Dans le <code class="code" id="-yitlcw_296">bootstrap.properties</code> d'un client, &agrave; quoi sert la propri&eacute;t&eacute; <code class="code" id="-yitlcw_297">spring.application.name</code>?</p><ul class="list _bullet" id="-yitlcw_294"><li class="list__item" id="-yitlcw_298"><p id="-yitlcw_302">A) &Agrave; nommer le conteneur Docker.</p></li><li class="list__item" id="-yitlcw_299"><p id="-yitlcw_303">B) C'est le nom que le client utilisera pour s'enregistrer aupr&egrave;s d'Eureka.</p></li><li class="list__item" id="-yitlcw_300"><p id="-yitlcw_304">C) C'est le nom que le client enverra au Config Server pour identifier le fichier de configuration qu'il doit recevoir.</p></li><li class="list__item" id="-yitlcw_301"><p id="-yitlcw_305">D) C'est juste un commentaire.</p></li></ul></li><li class="list__item" id="-yitlcw_278"><p id="-yitlcw_306"><span class="control" id="-yitlcw_307">(Question ouverte)</span> Expliquez le r&ocirc;le du fichier <code class="code" id="-yitlcw_308">application.properties</code> par rapport aux fichiers <code class="code" id="-yitlcw_309">{nom-du-service}.properties</code> dans le d&eacute;p&ocirc;t Git de configuration.</p></li><li class="list__item" id="-yitlcw_279"><p id="-yitlcw_310"><span class="control" id="-yitlcw_312">(QCM)</span> Pour utiliser un d&eacute;p&ocirc;t Git local comme backend pour le Config Server, comment doit commencer la valeur de la propri&eacute;t&eacute; <code class="code" id="-yitlcw_313">spring.cloud.config.server.git.uri</code>?</p><ul class="list _bullet" id="-yitlcw_311"><li class="list__item" id="-yitlcw_314"><p id="-yitlcw_318">A) <code class="code" id="-yitlcw_319">http://</code></p></li><li class="list__item" id="-yitlcw_315"><p id="-yitlcw_320">B) <code class="code" id="-yitlcw_321">git://</code></p></li><li class="list__item" id="-yitlcw_316"><p id="-yitlcw_322">C) <code class="code" id="-yitlcw_323">classpath:</code></p></li><li class="list__item" id="-yitlcw_317"><p id="-yitlcw_324">D) <code class="code" id="-yitlcw_325">file:///</code></p></li></ul></li></ol></section><section class="chapter"><h2 id="conclusion" data-toc="conclusion">Conclusion</h2><p id="-yitlcw_326">Vous avez franchi une &eacute;tape majeure dans la professionnalisation de votre architecture. En externalisant et centralisant la configuration, vous avez &eacute;limin&eacute; la duplication, am&eacute;lior&eacute; la s&eacute;curit&eacute; et rendu votre syst&egrave;me beaucoup plus facile &agrave; g&eacute;rer et &agrave; faire &eacute;voluer.</p><p id="-yitlcw_327">Vous avez mis en place toute la cha&icirc;ne : le <span class="control" id="-yitlcw_329">d&eacute;p&ocirc;t Git</span>, le <span class="control" id="-yitlcw_330">Config Server</span> qui le lit, et les <span class="control" id="-yitlcw_331">services clients</span> qui viennent y chercher leur configuration au d&eacute;marrage. Vous avez m&ecirc;me explor&eacute; la mise &agrave; jour &agrave; chaud, une fonctionnalit&eacute; tr&egrave;s puissante en production.</p><p id="-yitlcw_328">Notre &eacute;cosyst&egrave;me devient de plus en plus robuste. Nous avons des services qui se d&eacute;couvrent dynamiquement et qui sont configur&eacute;s de mani&egrave;re centralis&eacute;e. Mais que se passe-t-il si l'un d'eux tombe en panne ? C'est le dernier pilier de la stabilit&eacute; que nous allons aborder : la <span class="control" id="-yitlcw_332">r&eacute;silience</span> avec le pattern Circuit Breaker.</p></section><div class="last-modified">31 juillet 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="005-00-centralized-configuration.html" class="navigation-links__prev">Module 5 : La Configuration Centralis&eacute;e (L'essentiel)</a><a href="006-00-fault-tolerance.html" class="navigation-links__next">Module 6 : R&eacute;silience et Tol&eacute;rance aux Pannes - L'Art de ne pas s'effondrer (L'essentiel)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>