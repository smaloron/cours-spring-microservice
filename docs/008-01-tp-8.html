<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-27T21:24:57.213983"><title>... autres services | Spring Micro Services</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs Pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction-mettre-l-orchestre-en-musique","level":0,"title":"Introduction : Mettre l\u0027orchestre en musique","anchor":"#introduction-mettre-l-orchestre-en-musique"},{"id":"tape-1-pr-paration-du-projet-global","level":0,"title":"Étape 1 : Préparation du projet global","anchor":"#tape-1-pr-paration-du-projet-global"},{"id":"tape-2-construction-de-toutes-les-images-docker","level":0,"title":"Étape 2 : Construction de toutes les images Docker","anchor":"#tape-2-construction-de-toutes-les-images-docker"},{"id":"tape-3-criture-du-fichier-docker-compose-yml","level":0,"title":"Étape 3 : Écriture du fichier docker-compose.yml","anchor":"#tape-3-criture-du-fichier-docker-compose-yml"},{"id":"tape-4-lancement-et-validation-de-la-symphonie","level":0,"title":"Étape 4 : Lancement et validation de la symphonie","anchor":"#tape-4-lancement-et-validation-de-la-symphonie"},{"id":"exercice-11-optionnel-utiliser-une-vraie-base-de-donn-es","level":0,"title":"Exercice 11 (Optionnel) : Utiliser une \"vraie\" base de données","anchor":"#exercice-11-optionnel-utiliser-une-vraie-base-de-donn-es"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="... autres services | Spring Micro Services"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Spring Micro Services Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/008-01-tp-8.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="... autres services | Spring Micro Services"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/008-01-tp-8.html#webpage",
    "url": "writerside-documentation/008-01-tp-8.html",
    "name": "... autres services | Spring Micro Services",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Spring Micro Services Help"
}</script><!-- End Schema.org --></head><body data-id="008-01-TP-8" data-main-title="... autres services" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="008-00-docker-compose.md|Module 8 : Orchestration avec Docker Compose (L'essentiel)"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Spring Micro Services  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="008-01-TP-8" id="008-01-TP-8.md">... autres services</h1><p id="napl7b_2">Parfait. C'est l'heure du grand final d'assemblage. Nous allons prendre toutes les pi&egrave;ces que nous avons construites et les faire fonctionner ensemble sans effort gr&acirc;ce &agrave; Docker Compose.</p><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs P&eacute;dagogiques</h2><p id="napl7b_14">&Agrave; la fin de ce TP, vous serez capable de :</p><ul class="list _bullet" id="napl7b_15"><li class="list__item" id="napl7b_16"><p id="napl7b_22">Cr&eacute;er un fichier <code class="code" id="napl7b_23">docker-compose.yml</code> complet pour une architecture microservices.</p></li><li class="list__item" id="napl7b_17"><p id="napl7b_24">D&eacute;finir et configurer plusieurs services (Config Server, Eureka, services m&eacute;tier, Gateway).</p></li><li class="list__item" id="napl7b_18"><p id="napl7b_25">G&eacute;rer les d&eacute;pendances de d&eacute;marrage entre les services avec <code class="code" id="napl7b_26">depends_on</code>.</p></li><li class="list__item" id="napl7b_19"><p id="napl7b_27">Utiliser la r&eacute;solution de noms de Docker Compose pour la communication inter-conteneurs.</p></li><li class="list__item" id="napl7b_20"><p id="napl7b_28">Lancer et arr&ecirc;ter l'ensemble de l'&eacute;cosyst&egrave;me avec une seule commande.</p></li><li class="list__item" id="napl7b_21"><p id="napl7b_29">(Optionnel) Remplacer la base de donn&eacute;es H2 par un service PostgreSQL dans Docker Compose.</p></li></ul></section><section class="chapter"><h2 id="introduction-mettre-l-orchestre-en-musique" data-toc="introduction-mettre-l-orchestre-en-musique">Introduction : Mettre l'orchestre en musique</h2><p id="napl7b_30">Nous avons pass&eacute; beaucoup de temps &agrave; fabriquer chaque instrument de notre orchestre : le violon (<code class="code" id="napl7b_33">product-service</code>), le violoncelle (<code class="code" id="napl7b_34">order-service</code>), le piano (<code class="code" id="napl7b_35">config-server</code>), le m&eacute;tronome (<code class="code" id="napl7b_36">eureka-server</code>) et la partition du chef (<code class="code" id="napl7b_37">api-gateway</code>). Chaque instrument est parfaitement accord&eacute; et emball&eacute; dans sa bo&icirc;te (son image Docker).</p><p id="napl7b_31">Mais jusqu'&agrave; pr&eacute;sent, pour jouer un morceau, nous devions sortir chaque instrument de sa bo&icirc;te un par un, dans le bon ordre, et les placer sur la sc&egrave;ne. C'&eacute;tait fastidieux.</p><p id="napl7b_32">Avec ce TP, nous allons &eacute;crire la &quot;partition&quot; ultime : le fichier <span class="control" id="napl7b_38"><code class="code" id="napl7b_40">docker-compose.yml</code></span>. Ce fichier va d&eacute;crire l'ensemble de notre orchestre, qui doit jouer, o&ugrave; il doit se placer, et qui doit attendre qui. Une fois cette partition &eacute;crite, une seule commande du chef d'orchestre (<code class="code" id="napl7b_39">docker-compose up</code>) suffira pour que la symphonie commence. C'est l' &eacute;tape qui rend notre application facilement partageable et ex&eacute;cutable par n'importe quel d&eacute;veloppeur.</p></section><section class="chapter"><h2 id="tape-1-pr-paration-du-projet-global" data-toc="tape-1-pr-paration-du-projet-global">&Eacute;tape 1 : Pr&eacute;paration du projet global</h2><p id="napl7b_41">Pour une meilleure organisation, nous allons cr&eacute;er un fichier <code class="code" id="napl7b_43">docker-compose.yml</code> &agrave; la racine d'un projet &quot;parent&quot; qui englobe tous nos microservices.</p><section class="procedure-steps" id="napl7b_42"><p id="napl7b_44">1. Sur votre syst&egrave;me de fichiers, cr&eacute;ez un dossier parent, par exemple <code class="code" id="napl7b_48">gestbook-microservices</code>.</p><p id="napl7b_45">2. D&eacute;placez tous les dossiers de vos projets de microservices (`product-service`, `order-service`, `eureka-server`, `config-server`, `api-gateway`) et le dossier de configuration (`gestbook-config-repo`) &agrave; l'int&eacute;rieur de ce dossier parent.</p><p id="napl7b_46">Votre structure devrait ressembler &agrave; ceci :</p><div class="code-block" data-lang="none">
gestbook-microservices/
├── api-gateway/
├── config-server/
├── eureka-server/
├── order-service/
├── product-service/
├── gestbook-config-repo/
└── docker-compose.yml   &lt;-- Nous allons créer ce fichier
</div><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="tape-2-construction-de-toutes-les-images-docker" data-toc="tape-2-construction-de-toutes-les-images-docker">&Eacute;tape 2 : Construction de toutes les images Docker</h2><p id="napl7b_49">Avant de pouvoir orchestrer nos services, nous devons nous assurer que toutes nos images Docker sont &agrave; jour.</p><section class="procedure-steps" id="napl7b_50"><p id="napl7b_51">Pour chaque service (`config-server`, `eureka-server`, `product-service`, `order-service`, `api-gateway`), naviguez dans son dossier et ex&eacute;cutez les commandes :</p><p id="napl7b_53">R&eacute;p&eacute;tez cette op&eacute;ration pour tous les services, en veillant &agrave; bien nommer chaque image (ex: `api-gateway:latest`, `config-server:latest`, etc.). L'utilisation du tag `latest` est courante en d&eacute;veloppement.</p><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="tape-3-criture-du-fichier-docker-compose-yml" data-toc="tape-3-criture-du-fichier-docker-compose-yml">&Eacute;tape 3 : &Eacute;criture du fichier <code class="code" id="napl7b_58">docker-compose.yml</code></h2><p id="napl7b_55">&Agrave; la racine de votre dossier <code class="code" id="napl7b_59">gestbook-microservices</code>, cr&eacute;ez le fichier <code class="code" id="napl7b_60">docker-compose.yml</code> et ajoutez-y le contenu suivant. Nous allons le construire bloc par bloc.</p><div class="code-block" data-lang="yaml">
# Version de la syntaxe Docker Compose
version: '3.8'

# Définition de tous nos services (conteneurs)
services:

  # 1. Le Config Server : il doit démarrer en premier
  config-server:
    image: config-server:latest # L'image que nous avons construite
    ports:
      - &quot;8888:8888&quot; # Expose son port sur la machine hôte
    volumes:
      # On monte le dossier de configuration local directement dans le conteneur.
      # C'est très pratique en développement pour voir les changements
      # sans avoir à reconstruire l'image du config-server.
      - ./gestbook-config-repo:/config-repo
    environment:
      # On surcharge l'URI Git pour qu'elle pointe vers le volume monté.
      - SPRING_CLOUD_CONFIG_SERVER_GIT_URI=file:///config-repo
      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka
    healthcheck:
      # Vérifie que le service est réellement prêt
      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8888/actuator/health&quot; ]
      interval: 30s
      timeout: 10s
      retries: 5

  # 2. Le Serveur Eureka : il dépend du Config Server pour sa configuration
  eureka-server:
    image: eureka-server:latest
    ports:
      - &quot;8761:8761&quot;
    environment:
      # On lui dit où trouver le Config Server dans le réseau Docker
      - SPRING_CLOUD_CONFIG_URI=http://config-server:8888
    depends_on:
      config-server:
        condition: service_healthy # Attend que le healthcheck du config-server passe

  # 3. Le Product Service : dépend d'Eureka et du Config Server
  product-service:
    image: product-service:latest
    ports:
      - &quot;8081:8081&quot;
    environment:
      - SPRING_CLOUD_CONFIG_URI=http://config-server:8888
    depends_on:
      eureka-server:
        condition: service_started # On peut être moins strict ici
      config-server:
        condition: service_healthy

  # 4. Le Order Service : idem
  order-service:
    image: order-service:latest
    ports:
      - &quot;8082:8082&quot;
    environment:
      - SPRING_CLOUD_CONFIG_URI=http://config-server:8888
    depends_on:
      product-service: # Il dépend fonctionnellement de product-service
        condition: service_started
      eureka-server:
        condition: service_started
      config-server:
        condition: service_healthy

  # 5. L'API Gateway : la porte d'entrée
  api-gateway:
    image: api-gateway:latest
    ports:
      - &quot;8080:8080&quot; # Le seul port réellement nécessaire pour l'utilisateur final
    environment:
      - SPRING_CLOUD_CONFIG_URI=http://config-server:8888
    depends_on:
      eureka-server:
        condition: service_started
      config-server:
        condition: service_healthy

</div><aside class="prompt" data-type="warning" data-title="" id="napl7b_57"><p><b id="napl7b_61">D&eacute;pendances et Healthchecks</b></p><p id="napl7b_62">Notez l'utilisation de <code class="code" id="napl7b_64">depends_on</code> avec <code class="code" id="napl7b_65">condition: service_healthy</code> pour le <code class="code" id="napl7b_66">config-server</code>. C'est une mani&egrave;re plus robuste d'attendre qu'un service soit r&eacute;ellement pr&ecirc;t. Pour que cela fonctionne, il faut que le <code class="code" id="napl7b_67">config-server</code> expose un endpoint <code class="code" id="napl7b_68">/actuator/health</code> (ce qui est le cas si on a la d&eacute;pendance Actuator).</p><p id="napl7b_63">Nous avons aussi ajust&eacute; les URLs pour utiliser les noms de service Docker (ex: <code class="code" id="napl7b_69">http://config-server:8888</code>). C'est la magie de la r&eacute;solution de nom interne de Docker Compose !</p></aside></section><section class="chapter"><h2 id="tape-4-lancement-et-validation-de-la-symphonie" data-toc="tape-4-lancement-et-validation-de-la-symphonie">&Eacute;tape 4 : Lancement et validation de la symphonie</h2><section class="procedure-steps" id="napl7b_70"><p id="napl7b_72">1. Assurez-vous qu'aucun des conteneurs pr&eacute;c&eacute;dents ne tourne (`docker stop $(docker ps -aq)` peut &ecirc;tre utile pour tout arr&ecirc;ter).</p><p id="napl7b_73">2. Ouvrez un terminal &agrave; la racine de votre projet `gestbook-microservices`.</p><p id="napl7b_74">3. Lancez la commande magique :</p><p id="napl7b_76">Vous allez voir un flot de logs color&eacute;s, chaque couleur correspondant &agrave; un service. Docker Compose va d&eacute;marrer les conteneurs dans l'ordre d&eacute;fini par `depends_on`.</p><p id="napl7b_77">Attendez que les logs se stabilisent et que tous les services aient d&eacute;marr&eacute; et se soient enregistr&eacute;s aupr&egrave;s d'Eureka.</p><p id="napl7b_78">4. <b id="napl7b_85">Validation :</b></p><ul class="list _bullet" id="napl7b_79"><li class="list__item" id="napl7b_86"><p>Ouvrez <a href="http://localhost:8761/" id="napl7b_89" data-external="true" rel="noopener noreferrer" target="_blank">http://localhost:8761/</a> pour voir le dashboard Eureka. Tous vos services (<code class="code" id="napl7b_90">CONFIG-SERVER</code>, <code class="code" id="napl7b_91">PRODUCT-SERVICE</code>, <code class="code" id="napl7b_92">ORDER-SERVICE</code>, <code class="code" id="napl7b_93">API-GATEWAY</code>) devraient y &ecirc;tre list&eacute;s.</p></li><li class="list__item" id="napl7b_87"><p>Ouvrez <a href="http://localhost:8888/product-service/default" id="napl7b_94" data-external="true" rel="noopener noreferrer" target="_blank">http://localhost:8888/product-service/default</a> pour v&eacute;rifier que le Config Server est accessible et sert la bonne configuration.</p></li><li class="list__item" id="napl7b_88"><p>Utilisez votre client HTTP pour faire un appel de bout en bout, <b id="napl7b_95">en passant uniquement par la Gateway</b>:</p></li></ul><div class="code-block" data-lang="http">
### End-to-End Test with Docker Compose
POST http://localhost:8080/api/orders
Content-Type: application/json

{
&quot;productId&quot;: 2,
&quot;quantity&quot;: 1
}
</div><p id="napl7b_81">Si vous recevez une r&eacute;ponse `201 Created`, c'est un succ&egrave;s total ! Votre requ&ecirc;te a travers&eacute; la Gateway, qui a contact&eacute; `order-service`, qui a lui-m&ecirc;me contact&eacute; `product-service`, le tout orchestr&eacute; par Docker Compose et dynamiquement li&eacute; par Eureka et le Config Server.</p><p id="napl7b_82">5. Pour tout arr&ecirc;ter proprement, ouvrez un autre terminal dans le m&ecirc;me dossier et tapez :</p><p id="napl7b_84">Tous les conteneurs et le r&eacute;seau seront nettoy&eacute;s.</p><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="exercice-11-optionnel-utiliser-une-vraie-base-de-donn-es" data-toc="exercice-11-optionnel-utiliser-une-vraie-base-de-donn-es">Exercice 11 (Optionnel) : Utiliser une &quot;vraie&quot; base de donn&eacute;es</h2><p id="napl7b_96"><span class="control" id="napl7b_100">Contexte :</span> La base de donn&eacute;es en m&eacute;moire H2 est pratique, mais elle perd toutes ses donn&eacute;es &agrave; chaque red&eacute;marrage. Rempla&ccedil;ons-la par un service PostgreSQL dans notre <code class="code" id="napl7b_101">docker-compose.yml</code>.</p><p id="napl7b_97"><span class="control" id="napl7b_102">Votre mission :</span></p><ol class="list _decimal" id="napl7b_98" type="1"><li class="list__item" id="napl7b_103"><p id="napl7b_109">Dans <code class="code" id="napl7b_110">docker-compose.yml</code>, ajoutez un nouveau service nomm&eacute; <code class="code" id="napl7b_111">postgres-db</code>. Utilisez une image officielle comme <code class="code" id="napl7b_112">postgres:13</code>. Vous devrez configurer des variables d'environnement pour le mot de passe, l'utilisateur et le nom de la base de donn&eacute;es (ex: <code class="code" id="napl7b_113">POSTGRES_PASSWORD</code>, <code class="code" id="napl7b_114">POSTGRES_USER</code>, <code class="code" id="napl7b_115">POSTGRES_DB</code>).</p></li><li class="list__item" id="napl7b_104"><p id="napl7b_116">Dans <code class="code" id="napl7b_117">docker-compose.yml</code>, faites en sorte que <code class="code" id="napl7b_118">product-service</code> et <code class="code" id="napl7b_119">order-service</code> d&eacute;pendent de <code class="code" id="napl7b_120">postgres-db</code> (<code class="code" id="napl7b_121">depends_on</code>).</p></li><li class="list__item" id="napl7b_105"><p id="napl7b_122">Dans le d&eacute;p&ocirc;t <code class="code" id="napl7b_123">gestbook-config-repo</code>, modifiez les fichiers <code class="code" id="napl7b_124">product-service.properties</code> et <code class="code" id="napl7b_125">order-service.properties</code>. Remplacez la configuration H2 par la configuration de la source de donn&eacute;es PostgreSQL. L'URL JDBC ressemblera &agrave; <code class="code" id="napl7b_126">jdbc:postgresql://postgres-db:5432/gestbook_db</code>. Le <code class="code" id="napl7b_127">driver-class-name</code> sera <code class="code" id="napl7b_128">org.postgresql.Driver</code>. Utilisez les variables d'environnement pour le nom d'utilisateur et le mot de passe.</p></li><li class="list__item" id="napl7b_106"><p id="napl7b_129">Dans les <code class="code" id="napl7b_130">pom.xml</code> de <code class="code" id="napl7b_131">product-service</code> et <code class="code" id="napl7b_132">order-service</code>, remplacez la d&eacute;pendance <code class="code" id="napl7b_133">h2</code> par celle du driver PostgreSQL : <code class="code" id="napl7b_134">postgresql</code>.</p></li><li class="list__item" id="napl7b_107"><p id="napl7b_135">Reconstruisez les images de <code class="code" id="napl7b_136">product-service</code> et <code class="code" id="napl7b_137">order-service</code>.</p></li><li class="list__item" id="napl7b_108"><p id="napl7b_138">Lancez <code class="code" id="napl7b_139">docker-compose up</code> et v&eacute;rifiez que tout fonctionne. Cr&eacute;ez un produit (il faudra ajouter un endpoint <code class="code" id="napl7b_140">POST</code> dans <code class="code" id="napl7b_141">ProductController</code>). Arr&ecirc;tez et red&eacute;marrez tout avec <code class="code" id="napl7b_142">docker-compose down</code> puis <code class="code" id="napl7b_143">up</code>. Le produit que vous avez cr&eacute;&eacute; est-il toujours l&agrave; ? (Indice : il vous faudra utiliser un <code class="code" id="napl7b_144">volume</code> sur le service <code class="code" id="napl7b_145">postgres-db</code> pour persister les donn&eacute;es).</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="correction-exercice-11" data-toc="correction-exercice-11">Correction exercice 11</h3></div><div class="collapse__content"><ol class="list _decimal" id="napl7b_146" type="1"><li class="list__item" id="napl7b_148"><p id="napl7b_153"><span class="control" id="napl7b_155">Ajout du service PostgreSQL dans <code class="code" id="napl7b_156">docker-compose.yml</code></span>:</p><div class="code-block" data-lang="yaml">
services:
  # ... autres services
  postgres-db:
    image: postgres:13
    environment:
      - POSTGRES_USER=gestbook
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=gestbook_db
    ports:
      - &quot;5432:5432&quot; # Utile pour se connecter avec un client DB externe
    volumes:
      # Ce volume persistera les données de la DB entre les 'down' et 'up'
      - postgres_data:/var/lib/postgresql/data

# ...
volumes:
  postgres_data: # Déclaration du volume nommé
</div></li><li class="list__item" id="napl7b_149"><p id="napl7b_157"><span class="control" id="napl7b_159">Mise &agrave; jour des d&eacute;pendances de service</span>:</p><div class="code-block" data-lang="yaml">
# Dans la définition de product-service et order-service
depends_on:
  # ... autres dépendances
  postgres-db:
    condition: service_started
</div></li><li class="list__item" id="napl7b_150"><p id="napl7b_160"><span class="control" id="napl7b_162">Mise &agrave; jour de <code class="code" id="napl7b_163">product-service.properties</code> (idem pour <code class="code" id="napl7b_164">order-service</code>)</span>:</p><div class="code-block" data-lang="properties">
# server.port=8081
spring.datasource.url=jdbc:postgresql://postgres-db:5432/gestbook_db
spring.datasource.username=gestbook
spring.datasource.password=password
spring.datasource.driver-class-name=org.postgresql.Driver
# Permet à Hibernate de générer le schéma au démarrage
spring.jpa.hibernate.ddl-auto=update
</div></li><li class="list__item" id="napl7b_151"><p id="napl7b_165"><span class="control" id="napl7b_167">Mise &agrave; jour des <code class="code" id="napl7b_168">pom.xml</code></span>:</p><div class="code-block" data-lang="markup">
&lt;!-- Remplacer h2 par --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</div></li><li class="list__item" id="napl7b_152"><p id="napl7b_169">et 6. Apr&egrave;s avoir reconstruit les images et lanc&eacute; <code class="code" id="napl7b_170">docker-compose up</code>, les services se connecteront &agrave; la base de donn&eacute;es PostgreSQL. Gr&acirc;ce au volume <code class="code" id="napl7b_171">postgres_data</code>, les donn&eacute;es cr&eacute;&eacute;es persisteront m&ecirc;me apr&egrave;s un <code class="code" id="napl7b_172">docker-compose down</code>.</p></li></ol></div></div></section></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><ol class="list _decimal" id="napl7b_173" type="1"><li class="list__item" id="napl7b_175"><p id="napl7b_180"><span class="control" id="napl7b_182">(QCM)</span> Quelle est la commande pour lancer un &eacute;cosyst&egrave;me Docker Compose et voir les logs en direct ?</p><ul class="list _bullet" id="napl7b_181"><li class="list__item" id="napl7b_183"><p id="napl7b_187">A) <code class="code" id="napl7b_188">docker-compose start</code></p></li><li class="list__item" id="napl7b_184"><p id="napl7b_189">B) <code class="code" id="napl7b_190">docker-compose up -d</code></p></li><li class="list__item" id="napl7b_185"><p id="napl7b_191">C) <code class="code" id="napl7b_192">docker-compose up</code></p></li><li class="list__item" id="napl7b_186"><p id="napl7b_193">D) <code class="code" id="napl7b_194">docker-compose logs</code></p></li></ul></li><li class="list__item" id="napl7b_176"><p id="napl7b_195"><span class="control" id="napl7b_196">(Question ouverte)</span> Dans notre <code class="code" id="napl7b_197">docker-compose.yml</code>, <code class="code" id="napl7b_198">product-service</code> est configur&eacute; avec <code class="code" id="napl7b_199">SPRING_CLOUD_CONFIG_URI=http://config-server:8888</code>. Expliquez comment <code class="code" id="napl7b_200">product-service</code> peut r&eacute;soudre le nom d'h&ocirc;te <code class="code" id="napl7b_201">config-server</code>.</p></li><li class="list__item" id="napl7b_177"><p id="napl7b_202"><span class="control" id="napl7b_204">(QCM)</span> La directive <code class="code" id="napl7b_205">depends_on</code> dans Docker Compose :</p><ul class="list _bullet" id="napl7b_203"><li class="list__item" id="napl7b_206"><p id="napl7b_210">A) Garantit que le service d&eacute;pendant est pleinement op&eacute;rationnel avant de lancer le suivant.</p></li><li class="list__item" id="napl7b_207"><p id="napl7b_211">B) Contr&ocirc;le uniquement l'ordre de d&eacute;marrage des conteneurs.</p></li><li class="list__item" id="napl7b_208"><p id="napl7b_212">C) Cr&eacute;e un lien r&eacute;seau direct entre les conteneurs.</p></li><li class="list__item" id="napl7b_209"><p id="napl7b_213">D) N'est plus support&eacute;e dans la version 3.</p></li></ul></li><li class="list__item" id="napl7b_178"><p id="napl7b_214"><span class="control" id="napl7b_215">(Question ouverte)</span> Pourquoi avons-nous mont&eacute; le dossier <code class="code" id="napl7b_216">gestbook-config-repo</code> en tant que <code class="code" id="napl7b_217">volume</code> pour le <code class="code" id="napl7b_218">config-server</code> dans notre <code class="code" id="napl7b_219">docker-compose.yml</code>? Quel est l'avantage en d&eacute;veloppement ?</p></li><li class="list__item" id="napl7b_179"><p id="napl7b_220"><span class="control" id="napl7b_222">(QCM)</span> Pour arr&ecirc;ter et supprimer proprement tous les services lanc&eacute;s par Docker Compose, on utilise :</p><ul class="list _bullet" id="napl7b_221"><li class="list__item" id="napl7b_223"><p id="napl7b_227">A) <code class="code" id="napl7b_228">docker stop all</code></p></li><li class="list__item" id="napl7b_224"><p id="napl7b_229">B) <code class="code" id="napl7b_230">docker-compose kill</code></p></li><li class="list__item" id="napl7b_225"><p id="napl7b_231">C) <code class="code" id="napl7b_232">docker-compose stop</code></p></li><li class="list__item" id="napl7b_226"><p id="napl7b_233">D) <code class="code" id="napl7b_234">docker-compose down</code></p></li></ul></li></ol></section><section class="chapter"><h2 id="conclusion" data-toc="conclusion">Conclusion</h2><p id="napl7b_235">C'est un moment d&eacute;cisif. Vous avez assembl&eacute; et orchestr&eacute; une architecture microservices compl&egrave;te, du serveur de configuration jusqu'&agrave; la passerelle API, avec une seule commande. Vous avez transform&eacute; un processus de d&eacute;marrage complexe et manuel en une op&eacute;ration simple, fiable et reproductible.</p><p id="napl7b_236"><span class="control" id="napl7b_239">Docker Compose</span> est d&eacute;sormais un outil essentiel dans votre bo&icirc;te &agrave; outils de d&eacute;veloppeur. Il vous permet de :</p><ul class="list _bullet" id="napl7b_237"><li class="list__item" id="napl7b_240"><p id="napl7b_243">D&eacute;finir votre environnement de d&eacute;veloppement de mani&egrave;re d&eacute;clarative.</p></li><li class="list__item" id="napl7b_241"><p id="napl7b_244">Simplifier la collaboration au sein de votre &eacute;quipe.</p></li><li class="list__item" id="napl7b_242"><p id="napl7b_245">Simuler de mani&egrave;re r&eacute;aliste un environnement de production multi-conteneurs.</p></li></ul><p id="napl7b_238">Notre architecture est maintenant fonctionnelle, dynamique, configurable, r&eacute;siliente et facile &agrave; lancer. Nous avons construit des fondations solides. Il est temps maintenant de s'attaquer &agrave; des sujets plus avanc&eacute;s qui rendent ces architectures pr&ecirc;tes pour la production, comme la <span class="control" id="napl7b_246">s&eacute;curit&eacute;</span>, le <span class="control" id="napl7b_247">monitoring</span> et les <span class="control" id="napl7b_248">logs centralis&eacute;s</span>. L'aventure continue</p></section><div class="last-modified">17 juillet 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="008-00-docker-compose.html" class="navigation-links__prev">Module 8 : Orchestration avec Docker Compose (L'essentiel)</a><a href="009-00-security.html" class="navigation-links__next">Module 9 : S&eacute;curit&eacute; Avanc&eacute;e avec Spring Security &amp; OAuth2/OIDC (L'essentiel)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>