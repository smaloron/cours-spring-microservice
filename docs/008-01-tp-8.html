<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-31T08:30:08.707891"><title>... autres services | Spring Micro Services</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs Pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction-mettre-l-orchestre-en-musique","level":0,"title":"Introduction : Mettre l\u0027orchestre en musique","anchor":"#introduction-mettre-l-orchestre-en-musique"},{"id":"tape-1-pr-paration-du-projet-global","level":0,"title":"Étape 1 : Préparation du projet global","anchor":"#tape-1-pr-paration-du-projet-global"},{"id":"tape-2-construction-de-toutes-les-images-docker","level":0,"title":"Étape 2 : Construction de toutes les images Docker","anchor":"#tape-2-construction-de-toutes-les-images-docker"},{"id":"tape-3-criture-du-fichier-docker-compose-yml","level":0,"title":"Étape 3 : Écriture du fichier docker-compose.yml","anchor":"#tape-3-criture-du-fichier-docker-compose-yml"},{"id":"tape-4-lancement-et-validation-de-la-symphonie","level":0,"title":"Étape 4 : Lancement et validation de la symphonie","anchor":"#tape-4-lancement-et-validation-de-la-symphonie"},{"id":"exercice-11-optionnel-utiliser-une-vraie-base-de-donn-es","level":0,"title":"Exercice 11 (Optionnel) : Utiliser une \"vraie\" base de données","anchor":"#exercice-11-optionnel-utiliser-une-vraie-base-de-donn-es"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="... autres services | Spring Micro Services"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Spring Micro Services Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/008-01-tp-8.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="... autres services | Spring Micro Services"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/008-01-tp-8.html#webpage",
    "url": "writerside-documentation/008-01-tp-8.html",
    "name": "... autres services | Spring Micro Services",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Spring Micro Services Help"
}</script><!-- End Schema.org --></head><body data-id="008-01-TP-8" data-main-title="... autres services" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="008-00-docker-compose.md|Module 8 : Orchestration avec Docker Compose (L'essentiel)"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Spring Micro Services  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="008-01-TP-8" id="008-01-TP-8.md">... autres services</h1><p id="-s47lt2_2">Parfait. C'est l'heure du grand final d'assemblage. Nous allons prendre toutes les pi&egrave;ces que nous avons construites et les faire fonctionner ensemble sans effort gr&acirc;ce &agrave; Docker Compose.</p><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs P&eacute;dagogiques</h2><p id="-s47lt2_14">&Agrave; la fin de ce TP, vous serez capable de :</p><ul class="list _bullet" id="-s47lt2_15"><li class="list__item" id="-s47lt2_16"><p id="-s47lt2_22">Cr&eacute;er un fichier <code class="code" id="-s47lt2_23">docker-compose.yml</code> complet pour une architecture microservices.</p></li><li class="list__item" id="-s47lt2_17"><p id="-s47lt2_24">D&eacute;finir et configurer plusieurs services (Config Server, Eureka, services m&eacute;tier, Gateway).</p></li><li class="list__item" id="-s47lt2_18"><p id="-s47lt2_25">G&eacute;rer les d&eacute;pendances de d&eacute;marrage entre les services avec <code class="code" id="-s47lt2_26">depends_on</code>.</p></li><li class="list__item" id="-s47lt2_19"><p id="-s47lt2_27">Utiliser la r&eacute;solution de noms de Docker Compose pour la communication inter-conteneurs.</p></li><li class="list__item" id="-s47lt2_20"><p id="-s47lt2_28">Lancer et arr&ecirc;ter l'ensemble de l'&eacute;cosyst&egrave;me avec une seule commande.</p></li><li class="list__item" id="-s47lt2_21"><p id="-s47lt2_29">(Optionnel) Remplacer la base de donn&eacute;es H2 par un service PostgreSQL dans Docker Compose.</p></li></ul></section><section class="chapter"><h2 id="introduction-mettre-l-orchestre-en-musique" data-toc="introduction-mettre-l-orchestre-en-musique">Introduction : Mettre l'orchestre en musique</h2><p id="-s47lt2_30">Nous avons pass&eacute; beaucoup de temps &agrave; fabriquer chaque instrument de notre orchestre : le violon (<code class="code" id="-s47lt2_33">product-service</code>), le violoncelle (<code class="code" id="-s47lt2_34">order-service</code>), le piano (<code class="code" id="-s47lt2_35">config-server</code>), le m&eacute;tronome (<code class="code" id="-s47lt2_36">eureka-server</code>) et la partition du chef (<code class="code" id="-s47lt2_37">api-gateway</code>). Chaque instrument est parfaitement accord&eacute; et emball&eacute; dans sa bo&icirc;te (son image Docker).</p><p id="-s47lt2_31">Mais jusqu'&agrave; pr&eacute;sent, pour jouer un morceau, nous devions sortir chaque instrument de sa bo&icirc;te un par un, dans le bon ordre, et les placer sur la sc&egrave;ne. C'&eacute;tait fastidieux.</p><p id="-s47lt2_32">Avec ce TP, nous allons &eacute;crire la &quot;partition&quot; ultime : le fichier <span class="control" id="-s47lt2_38"><code class="code" id="-s47lt2_40">docker-compose.yml</code></span>. Ce fichier va d&eacute;crire l'ensemble de notre orchestre, qui doit jouer, o&ugrave; il doit se placer, et qui doit attendre qui. Une fois cette partition &eacute;crite, une seule commande du chef d'orchestre (<code class="code" id="-s47lt2_39">docker-compose up</code>) suffira pour que la symphonie commence. C'est l' &eacute;tape qui rend notre application facilement partageable et ex&eacute;cutable par n'importe quel d&eacute;veloppeur.</p></section><section class="chapter"><h2 id="tape-1-pr-paration-du-projet-global" data-toc="tape-1-pr-paration-du-projet-global">&Eacute;tape 1 : Pr&eacute;paration du projet global</h2><p id="-s47lt2_41">Pour une meilleure organisation, nous allons cr&eacute;er un fichier <code class="code" id="-s47lt2_43">docker-compose.yml</code> &agrave; la racine d'un projet &quot;parent&quot; qui englobe tous nos microservices.</p><section class="procedure-steps" id="-s47lt2_42"><p id="-s47lt2_44">1. Sur votre syst&egrave;me de fichiers, cr&eacute;ez un dossier parent, par exemple <code class="code" id="-s47lt2_48">gestbook-microservices</code>.</p><p id="-s47lt2_45">2. D&eacute;placez tous les dossiers de vos projets de microservices (`product-service`, `order-service`, `eureka-server`, `config-server`, `api-gateway`) et le dossier de configuration (`gestbook-config-repo`) &agrave; l'int&eacute;rieur de ce dossier parent.</p><p id="-s47lt2_46">Votre structure devrait ressembler &agrave; ceci :</p><div class="code-block" data-lang="none">
gestbook-microservices/
├── api-gateway/
├── config-server/
├── eureka-server/
├── order-service/
├── product-service/
├── gestbook-config-repo/
└── docker-compose.yml   &lt;-- Nous allons créer ce fichier
</div><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="tape-2-construction-de-toutes-les-images-docker" data-toc="tape-2-construction-de-toutes-les-images-docker">&Eacute;tape 2 : Construction de toutes les images Docker</h2><p id="-s47lt2_49">Avant de pouvoir orchestrer nos services, nous devons nous assurer que toutes nos images Docker sont &agrave; jour.</p><section class="procedure-steps" id="-s47lt2_50"><p id="-s47lt2_51">Pour chaque service (`config-server`, `eureka-server`, `product-service`, `order-service`, `api-gateway`), naviguez dans son dossier et ex&eacute;cutez les commandes :</p><div class="code-block" data-lang="bash">
# Exemple pour product-service
cd product-service
mvn clean package
docker build -t product-service:latest .
cd ..
</div><p id="-s47lt2_53">R&eacute;p&eacute;tez cette op&eacute;ration pour tous les services, en veillant &agrave; bien nommer chaque image (ex: `api-gateway:latest`, `config-server:latest`, etc.). L'utilisation du tag `latest` est courante en d&eacute;veloppement.</p><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="tape-3-criture-du-fichier-docker-compose-yml" data-toc="tape-3-criture-du-fichier-docker-compose-yml">&Eacute;tape 3 : &Eacute;criture du fichier <code class="code" id="-s47lt2_58">docker-compose.yml</code></h2><p id="-s47lt2_55">&Agrave; la racine de votre dossier <code class="code" id="-s47lt2_59">gestbook-microservices</code>, cr&eacute;ez le fichier <code class="code" id="-s47lt2_60">docker-compose.yml</code> et ajoutez-y le contenu suivant. Nous allons le construire bloc par bloc.</p><div class="code-block" data-lang="yaml">
# Version de la syntaxe Docker Compose
version: '3.8'

# Définition de tous nos services (conteneurs)
services:

  # 1. Le Config Server : il doit démarrer en premier
  config-server:
    image: config-server:latest # L'image que nous avons construite
    ports:
      - &quot;8888:8888&quot; # Expose son port sur la machine hôte
    volumes:
      # On monte le dossier de configuration local directement dans le conteneur.
      # C'est très pratique en développement pour voir les changements
      # sans avoir à reconstruire l'image du config-server.
      - ./gestbook-config-repo:/config-repo
    environment:
      # On surcharge l'URI Git pour qu'elle pointe vers le volume monté.
      - SPRING_CLOUD_CONFIG_SERVER_GIT_URI=file:///config-repo
      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka
    healthcheck:
      # Vérifie que le service est réellement prêt
      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8888/actuator/health&quot; ]
      interval: 30s
      timeout: 10s
      retries: 5

  # 2. Le Serveur Eureka : il dépend du Config Server pour sa configuration
  eureka-server:
    image: eureka-server:latest
    ports:
      - &quot;8761:8761&quot;
    environment:
      # On lui dit où trouver le Config Server dans le réseau Docker
      - SPRING_CLOUD_CONFIG_URI=http://config-server:8888
    depends_on:
      config-server:
        condition: service_healthy # Attend que le healthcheck du config-server passe

  # 3. Le Product Service : dépend d'Eureka et du Config Server
  product-service:
    image: product-service:latest
    ports:
      - &quot;8081:8081&quot;
    environment:
      - SPRING_CLOUD_CONFIG_URI=http://config-server:8888
    depends_on:
      eureka-server:
        condition: service_started # On peut être moins strict ici
      config-server:
        condition: service_healthy

  # 4. Le Order Service : idem
  order-service:
    image: order-service:latest
    ports:
      - &quot;8082:8082&quot;
    environment:
      - SPRING_CLOUD_CONFIG_URI=http://config-server:8888
    depends_on:
      product-service: # Il dépend fonctionnellement de product-service
        condition: service_started
      eureka-server:
        condition: service_started
      config-server:
        condition: service_healthy

  # 5. L'API Gateway : la porte d'entrée
  api-gateway:
    image: api-gateway:latest
    ports:
      - &quot;8080:8080&quot; # Le seul port réellement nécessaire pour l'utilisateur final
    environment:
      - SPRING_CLOUD_CONFIG_URI=http://config-server:8888
    depends_on:
      eureka-server:
        condition: service_started
      config-server:
        condition: service_healthy

</div><aside class="prompt" data-type="warning" data-title="" id="-s47lt2_57"><p><b id="-s47lt2_61">D&eacute;pendances et Healthchecks</b></p><p id="-s47lt2_62">Notez l'utilisation de <code class="code" id="-s47lt2_64">depends_on</code> avec <code class="code" id="-s47lt2_65">condition: service_healthy</code> pour le <code class="code" id="-s47lt2_66">config-server</code>. C'est une mani&egrave;re plus robuste d'attendre qu'un service soit r&eacute;ellement pr&ecirc;t. Pour que cela fonctionne, il faut que le <code class="code" id="-s47lt2_67">config-server</code> expose un endpoint <code class="code" id="-s47lt2_68">/actuator/health</code> (ce qui est le cas si on a la d&eacute;pendance Actuator).</p><p id="-s47lt2_63">Nous avons aussi ajust&eacute; les URLs pour utiliser les noms de service Docker (ex: <code class="code" id="-s47lt2_69">http://config-server:8888</code>). C'est la magie de la r&eacute;solution de nom interne de Docker Compose !</p></aside></section><section class="chapter"><h2 id="tape-4-lancement-et-validation-de-la-symphonie" data-toc="tape-4-lancement-et-validation-de-la-symphonie">&Eacute;tape 4 : Lancement et validation de la symphonie</h2><section class="procedure-steps" id="-s47lt2_70"><p id="-s47lt2_72">1. Assurez-vous qu'aucun des conteneurs pr&eacute;c&eacute;dents ne tourne (`docker stop $(docker ps -aq)` peut &ecirc;tre utile pour tout arr&ecirc;ter).</p><p id="-s47lt2_73">2. Ouvrez un terminal &agrave; la racine de votre projet `gestbook-microservices`.</p><p id="-s47lt2_74">3. Lancez la commande magique :</p><p id="-s47lt2_76">Vous allez voir un flot de logs color&eacute;s, chaque couleur correspondant &agrave; un service. Docker Compose va d&eacute;marrer les conteneurs dans l'ordre d&eacute;fini par `depends_on`.</p><p id="-s47lt2_77">Attendez que les logs se stabilisent et que tous les services aient d&eacute;marr&eacute; et se soient enregistr&eacute;s aupr&egrave;s d'Eureka.</p><p id="-s47lt2_78">4. <b id="-s47lt2_85">Validation :</b></p><ul class="list _bullet" id="-s47lt2_79"><li class="list__item" id="-s47lt2_86"><p>Ouvrez <a href="http://localhost:8761/" id="-s47lt2_89" data-external="true" rel="noopener noreferrer" target="_blank">http://localhost:8761/</a> pour voir le dashboard Eureka. Tous vos services (<code class="code" id="-s47lt2_90">CONFIG-SERVER</code>, <code class="code" id="-s47lt2_91">PRODUCT-SERVICE</code>, <code class="code" id="-s47lt2_92">ORDER-SERVICE</code>, <code class="code" id="-s47lt2_93">API-GATEWAY</code>) devraient y &ecirc;tre list&eacute;s.</p></li><li class="list__item" id="-s47lt2_87"><p>Ouvrez <a href="http://localhost:8888/product-service/default" id="-s47lt2_94" data-external="true" rel="noopener noreferrer" target="_blank">http://localhost:8888/product-service/default</a> pour v&eacute;rifier que le Config Server est accessible et sert la bonne configuration.</p></li><li class="list__item" id="-s47lt2_88"><p>Utilisez votre client HTTP pour faire un appel de bout en bout, <b id="-s47lt2_95">en passant uniquement par la Gateway</b>:</p></li></ul><div class="code-block" data-lang="http">
### End-to-End Test with Docker Compose
POST http://localhost:8080/api/orders
Content-Type: application/json

{
&quot;productId&quot;: 2,
&quot;quantity&quot;: 1
}
</div><p id="-s47lt2_81">Si vous recevez une r&eacute;ponse `201 Created`, c'est un succ&egrave;s total ! Votre requ&ecirc;te a travers&eacute; la Gateway, qui a contact&eacute; `order-service`, qui a lui-m&ecirc;me contact&eacute; `product-service`, le tout orchestr&eacute; par Docker Compose et dynamiquement li&eacute; par Eureka et le Config Server.</p><p id="-s47lt2_82">5. Pour tout arr&ecirc;ter proprement, ouvrez un autre terminal dans le m&ecirc;me dossier et tapez :</p><p id="-s47lt2_84">Tous les conteneurs et le r&eacute;seau seront nettoy&eacute;s.</p><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="exercice-11-optionnel-utiliser-une-vraie-base-de-donn-es" data-toc="exercice-11-optionnel-utiliser-une-vraie-base-de-donn-es">Exercice 11 (Optionnel) : Utiliser une &quot;vraie&quot; base de donn&eacute;es</h2><p id="-s47lt2_96"><span class="control" id="-s47lt2_100">Contexte :</span> La base de donn&eacute;es en m&eacute;moire H2 est pratique, mais elle perd toutes ses donn&eacute;es &agrave; chaque red&eacute;marrage. Rempla&ccedil;ons-la par un service PostgreSQL dans notre <code class="code" id="-s47lt2_101">docker-compose.yml</code>.</p><p id="-s47lt2_97"><span class="control" id="-s47lt2_102">Votre mission :</span></p><ol class="list _decimal" id="-s47lt2_98" type="1"><li class="list__item" id="-s47lt2_103"><p id="-s47lt2_109">Dans <code class="code" id="-s47lt2_110">docker-compose.yml</code>, ajoutez un nouveau service nomm&eacute; <code class="code" id="-s47lt2_111">postgres-db</code>. Utilisez une image officielle comme <code class="code" id="-s47lt2_112">postgres:13</code>. Vous devrez configurer des variables d'environnement pour le mot de passe, l'utilisateur et le nom de la base de donn&eacute;es (ex: <code class="code" id="-s47lt2_113">POSTGRES_PASSWORD</code>, <code class="code" id="-s47lt2_114">POSTGRES_USER</code>, <code class="code" id="-s47lt2_115">POSTGRES_DB</code>).</p></li><li class="list__item" id="-s47lt2_104"><p id="-s47lt2_116">Dans <code class="code" id="-s47lt2_117">docker-compose.yml</code>, faites en sorte que <code class="code" id="-s47lt2_118">product-service</code> et <code class="code" id="-s47lt2_119">order-service</code> d&eacute;pendent de <code class="code" id="-s47lt2_120">postgres-db</code> (<code class="code" id="-s47lt2_121">depends_on</code>).</p></li><li class="list__item" id="-s47lt2_105"><p id="-s47lt2_122">Dans le d&eacute;p&ocirc;t <code class="code" id="-s47lt2_123">gestbook-config-repo</code>, modifiez les fichiers <code class="code" id="-s47lt2_124">product-service.properties</code> et <code class="code" id="-s47lt2_125">order-service.properties</code>. Remplacez la configuration H2 par la configuration de la source de donn&eacute;es PostgreSQL. L'URL JDBC ressemblera &agrave; <code class="code" id="-s47lt2_126">jdbc:postgresql://postgres-db:5432/gestbook_db</code>. Le <code class="code" id="-s47lt2_127">driver-class-name</code> sera <code class="code" id="-s47lt2_128">org.postgresql.Driver</code>. Utilisez les variables d'environnement pour le nom d'utilisateur et le mot de passe.</p></li><li class="list__item" id="-s47lt2_106"><p id="-s47lt2_129">Dans les <code class="code" id="-s47lt2_130">pom.xml</code> de <code class="code" id="-s47lt2_131">product-service</code> et <code class="code" id="-s47lt2_132">order-service</code>, remplacez la d&eacute;pendance <code class="code" id="-s47lt2_133">h2</code> par celle du driver PostgreSQL : <code class="code" id="-s47lt2_134">postgresql</code>.</p></li><li class="list__item" id="-s47lt2_107"><p id="-s47lt2_135">Reconstruisez les images de <code class="code" id="-s47lt2_136">product-service</code> et <code class="code" id="-s47lt2_137">order-service</code>.</p></li><li class="list__item" id="-s47lt2_108"><p id="-s47lt2_138">Lancez <code class="code" id="-s47lt2_139">docker-compose up</code> et v&eacute;rifiez que tout fonctionne. Cr&eacute;ez un produit (il faudra ajouter un endpoint <code class="code" id="-s47lt2_140">POST</code> dans <code class="code" id="-s47lt2_141">ProductController</code>). Arr&ecirc;tez et red&eacute;marrez tout avec <code class="code" id="-s47lt2_142">docker-compose down</code> puis <code class="code" id="-s47lt2_143">up</code>. Le produit que vous avez cr&eacute;&eacute; est-il toujours l&agrave; ? (Indice : il vous faudra utiliser un <code class="code" id="-s47lt2_144">volume</code> sur le service <code class="code" id="-s47lt2_145">postgres-db</code> pour persister les donn&eacute;es).</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="correction-exercice-11" data-toc="correction-exercice-11">Correction exercice 11</h3></div><div class="collapse__content"><ol class="list _decimal" id="-s47lt2_146" type="1"><li class="list__item" id="-s47lt2_156"><p id="-s47lt2_157"><span class="control" id="-s47lt2_158">Ajout du service PostgreSQL dans <code class="code" id="-s47lt2_159">docker-compose.yml</code></span>:</p></li></ol><div class="code-block" data-lang="yaml">
   services:
     # ... autres services
     postgres-db:
       image: postgres:13
       environment:
         - POSTGRES_USER=gestbook
         - POSTGRES_PASSWORD=password
         - POSTGRES_DB=gestbook_db
       ports:
         - &quot;5432:5432&quot; # Utile pour se connecter avec un client DB externe
       volumes:
         # Ce volume persistera les données de la DB entre les 'down' et 'up'
         - postgres_data:/var/lib/postgresql/data

   # ...
   volumes:
     postgres_data: # Déclaration du volume nommé
</div><ol class="list _decimal" id="-s47lt2_148" type="1" start="2"><li class="list__item" id="-s47lt2_160"><p id="-s47lt2_161"><span class="control" id="-s47lt2_162">Mise &agrave; jour des d&eacute;pendances de service</span>:</p></li></ol><div class="code-block" data-lang="yaml">
   # Dans la définition de product-service et order-service
   depends_on:
     # ... autres dépendances
     postgres-db:
       condition: service_started
</div><ol class="list _decimal" id="-s47lt2_150" type="1" start="3"><li class="list__item" id="-s47lt2_163"><p id="-s47lt2_164"><span class="control" id="-s47lt2_165">Mise &agrave; jour de <code class="code" id="-s47lt2_166">product-service.properties</code> (idem pour <code class="code" id="-s47lt2_167">order-service</code>)</span>:</p></li></ol><div class="code-block" data-lang="properties">
   # server.port=8081
   spring.datasource.url=jdbc:postgresql://postgres-db:5432/gestbook_db
   spring.datasource.username=gestbook
   spring.datasource.password=password
   spring.datasource.driver-class-name=org.postgresql.Driver
   # Permet à Hibernate de générer le schéma au démarrage
   spring.jpa.hibernate.ddl-auto=update
</div><ol class="list _decimal" id="-s47lt2_152" type="1" start="4"><li class="list__item" id="-s47lt2_168"><p id="-s47lt2_169"><span class="control" id="-s47lt2_170">Mise &agrave; jour des <code class="code" id="-s47lt2_171">pom.xml</code></span>:</p></li></ol><div class="code-block" data-lang="markup">
   &lt;!-- Remplacer h2 par --&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
       &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
       &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
</div><ol class="list _decimal" id="-s47lt2_154" type="1" start="5"><li class="list__item" id="-s47lt2_172"><p id="-s47lt2_173">et 6. Apr&egrave;s avoir reconstruit les images et lanc&eacute; <code class="code" id="-s47lt2_174">docker-compose up</code>, les services se connecteront &agrave; la base de donn&eacute;es PostgreSQL. Gr&acirc;ce au volume <code class="code" id="-s47lt2_175">postgres_data</code>, les donn&eacute;es cr&eacute;&eacute;es persisteront m&ecirc;me apr&egrave;s un <code class="code" id="-s47lt2_176">docker-compose down</code>.</p></li></ol></div></div></section></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><ol class="list _decimal" id="-s47lt2_177" type="1"><li class="list__item" id="-s47lt2_179"><p id="-s47lt2_184"><span class="control" id="-s47lt2_186">(QCM)</span> Quelle est la commande pour lancer un &eacute;cosyst&egrave;me Docker Compose et voir les logs en direct ?</p><ul class="list _bullet" id="-s47lt2_185"><li class="list__item" id="-s47lt2_187"><p id="-s47lt2_191">A) <code class="code" id="-s47lt2_192">docker-compose start</code></p></li><li class="list__item" id="-s47lt2_188"><p id="-s47lt2_193">B) <code class="code" id="-s47lt2_194">docker-compose up -d</code></p></li><li class="list__item" id="-s47lt2_189"><p id="-s47lt2_195">C) <code class="code" id="-s47lt2_196">docker-compose up</code></p></li><li class="list__item" id="-s47lt2_190"><p id="-s47lt2_197">D) <code class="code" id="-s47lt2_198">docker-compose logs</code></p></li></ul></li><li class="list__item" id="-s47lt2_180"><p id="-s47lt2_199"><span class="control" id="-s47lt2_200">(Question ouverte)</span> Dans notre <code class="code" id="-s47lt2_201">docker-compose.yml</code>, <code class="code" id="-s47lt2_202">product-service</code> est configur&eacute; avec <code class="code" id="-s47lt2_203">SPRING_CLOUD_CONFIG_URI=http://config-server:8888</code>. Expliquez comment <code class="code" id="-s47lt2_204">product-service</code> peut r&eacute;soudre le nom d'h&ocirc;te <code class="code" id="-s47lt2_205">config-server</code>.</p></li><li class="list__item" id="-s47lt2_181"><p id="-s47lt2_206"><span class="control" id="-s47lt2_208">(QCM)</span> La directive <code class="code" id="-s47lt2_209">depends_on</code> dans Docker Compose :</p><ul class="list _bullet" id="-s47lt2_207"><li class="list__item" id="-s47lt2_210"><p id="-s47lt2_214">A) Garantit que le service d&eacute;pendant est pleinement op&eacute;rationnel avant de lancer le suivant.</p></li><li class="list__item" id="-s47lt2_211"><p id="-s47lt2_215">B) Contr&ocirc;le uniquement l'ordre de d&eacute;marrage des conteneurs.</p></li><li class="list__item" id="-s47lt2_212"><p id="-s47lt2_216">C) Cr&eacute;e un lien r&eacute;seau direct entre les conteneurs.</p></li><li class="list__item" id="-s47lt2_213"><p id="-s47lt2_217">D) N'est plus support&eacute;e dans la version 3.</p></li></ul></li><li class="list__item" id="-s47lt2_182"><p id="-s47lt2_218"><span class="control" id="-s47lt2_219">(Question ouverte)</span> Pourquoi avons-nous mont&eacute; le dossier <code class="code" id="-s47lt2_220">gestbook-config-repo</code> en tant que <code class="code" id="-s47lt2_221">volume</code> pour le <code class="code" id="-s47lt2_222">config-server</code> dans notre <code class="code" id="-s47lt2_223">docker-compose.yml</code>? Quel est l'avantage en d&eacute;veloppement ?</p></li><li class="list__item" id="-s47lt2_183"><p id="-s47lt2_224"><span class="control" id="-s47lt2_226">(QCM)</span> Pour arr&ecirc;ter et supprimer proprement tous les services lanc&eacute;s par Docker Compose, on utilise :</p><ul class="list _bullet" id="-s47lt2_225"><li class="list__item" id="-s47lt2_227"><p id="-s47lt2_231">A) <code class="code" id="-s47lt2_232">docker stop all</code></p></li><li class="list__item" id="-s47lt2_228"><p id="-s47lt2_233">B) <code class="code" id="-s47lt2_234">docker-compose kill</code></p></li><li class="list__item" id="-s47lt2_229"><p id="-s47lt2_235">C) <code class="code" id="-s47lt2_236">docker-compose stop</code></p></li><li class="list__item" id="-s47lt2_230"><p id="-s47lt2_237">D) <code class="code" id="-s47lt2_238">docker-compose down</code></p></li></ul></li></ol></section><section class="chapter"><h2 id="conclusion" data-toc="conclusion">Conclusion</h2><p id="-s47lt2_239">C'est un moment d&eacute;cisif. Vous avez assembl&eacute; et orchestr&eacute; une architecture microservices compl&egrave;te, du serveur de configuration jusqu'&agrave; la passerelle API, avec une seule commande. Vous avez transform&eacute; un processus de d&eacute;marrage complexe et manuel en une op&eacute;ration simple, fiable et reproductible.</p><p id="-s47lt2_240"><span class="control" id="-s47lt2_243">Docker Compose</span> est d&eacute;sormais un outil essentiel dans votre bo&icirc;te &agrave; outils de d&eacute;veloppeur. Il vous permet de :</p><ul class="list _bullet" id="-s47lt2_241"><li class="list__item" id="-s47lt2_244"><p id="-s47lt2_247">D&eacute;finir votre environnement de d&eacute;veloppement de mani&egrave;re d&eacute;clarative.</p></li><li class="list__item" id="-s47lt2_245"><p id="-s47lt2_248">Simplifier la collaboration au sein de votre &eacute;quipe.</p></li><li class="list__item" id="-s47lt2_246"><p id="-s47lt2_249">Simuler de mani&egrave;re r&eacute;aliste un environnement de production multi-conteneurs.</p></li></ul><p id="-s47lt2_242">Notre architecture est maintenant fonctionnelle, dynamique, configurable, r&eacute;siliente et facile &agrave; lancer. Nous avons construit des fondations solides. Il est temps maintenant de s'attaquer &agrave; des sujets plus avanc&eacute;s qui rendent ces architectures pr&ecirc;tes pour la production, comme la <span class="control" id="-s47lt2_250">s&eacute;curit&eacute;</span>, le <span class="control" id="-s47lt2_251">monitoring</span> et les <span class="control" id="-s47lt2_252">logs centralis&eacute;s</span>. L'aventure continue</p></section><div class="last-modified">31 juillet 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="008-00-docker-compose.html" class="navigation-links__prev">Module 8 : Orchestration avec Docker Compose (L'essentiel)</a><a href="009-00-security.html" class="navigation-links__next">Module 9 : S&eacute;curit&eacute; Avanc&eacute;e avec Spring Security &amp; OAuth2/OIDC (L'essentiel)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>